# 01 여러 가지 자료구조

## 1. 선형 자료구조

* 앞의 요소와 뒤의 요소가 일대일의 관계이다.

### 1.1. 배열

![image](https://user-images.githubusercontent.com/27791880/152710673-d4b8fab9-d9ae-48b4-9d40-607620c358c7.png)

* 배열의 가장 큰 특징은 중간이 비어 있으면 안된다.

* 배열은 물리적 순서와 논리적 순서가 동일하다. 즉, 1번의 요소와 2번의 요소가 연달아 있다고 설명하면 그것이 실제로 메모리 상에도 해당 순서대로 배치되어 있어야 한다.

* 중간에 요소가 삭제되면 뒤의 요소를 당겨서 채워주어야 한다. 마찬가지로 중간에 요소를 삽입하려면 기존 요소들을 뒤로 밀어 공간을 만들어야 한다.

* 논리적 위치와 물리적 위치가 동일하기 때문에 특정 위치의 값을 가져오는 작업을 빠르게 수행할 수 있다.

* 자료를 넣고 뺄 때 소요되는 **computation time**은 배열의 개수에 의존적이기 때문에 배열의 개수가 n개라면 **O(n)** 이라고 표현한다.

### 1.2. 연결리스트 (LinkedList)

* 배열은 물리적으로 몇 개의 메모리를 사용할지 정한 뒤에 해당 사이즈만큼 할당을 받아서 사용한다. 

* 링크드리스트는 노드가 필요할 때 메모리를 할당받아서 사용한다.

* A, B, D 순서로 기존 노드들이 배치되어 있는데 여기서 B 뒤에 C를 추가하려면 C 뒤에 오는 노드는 D라고 알려준다.

* 링크드리스트는 다음 element를 가리키는 링크를 함께 가지고 있다. 이것이 C에서는 포인터로 작동한다. 자바에서는 객체의 참조변수를 가리키도록 구현하면 된다.

* 링크드리스트에서는 물리적 위치와 논리적 위치가 다를 수도 있다.

👉 LinkedList에 자료 추가하기

![image](https://user-images.githubusercontent.com/27791880/152711422-c85db79b-b9ed-48b4-8aaf-cdcd7e39afa2.png)

👉 LinkedList에서 자료 삭제하기

![image](https://user-images.githubusercontent.com/27791880/152711465-ed6f399f-0c9a-4287-afea-5613a1435e2b.png)

* 데이터를 추가하고 삭제하는 속도가 배열보다 linkedlist가 더 빠르다.

* 자료를 넣고 뺄 때 소요되는 **computation time**은 넣고 빼는 요소 한 가지에 대해서만 연산하면 되기 때문에 **O(1)** 이 된다.

* 한편, linkedlist는 배열처럼 index를 사용해서 특정 값을 찾아가는 것이 불가능하다. 따라서 논리적으로 연결된 순서에 따라서 원하는 값을 찾아가야 하는데, 이러한 문제 때문에 특정 값을 찾는데 소요되는 시간이 요소의 개수에 의존적이기 때문에 이 때는 **O(n)** 으로 표현할 수 있다.

### 배열과 링크드리스트의 차이점

* 배열은 자료의 추가삭제 비용이 크다. 그러나 원하는 자료의 위치를 아는 경우  자료를 꺼내오거나 검색하는 비용은 적다.

* Linkedlist는 자료의 추가삭제 비용은 적지만 특정 위치의 element를 찾는데 소요되는 시간은 배열보다 더 많이 걸린다.

### 1.3. 스택(stack)

* 가장 나중에 들어간 요소가 가장 먼저 나오게 된다. (LIFO, Last In First Out)

![image](https://user-images.githubusercontent.com/27791880/152714214-2e0ca0da-7460-4612-b83b-04b51f0c8155.png)

* DFS(깊이 우선 탐색)를 할 때도 스택을 활용한다.

### 1.4. 큐(Queue)

* 가장 먼저 입력된 자료가 가장 먼저 출력된다. (FIFO, First In First Out)

![image](https://user-images.githubusercontent.com/27791880/152714462-fba7b302-1d31-4459-bf1c-2a68b1acc72c.png)

* 큐에서 dequeue를 계속하게 되면 front의 메모리가 빈 공간이 되고 메모리를 낭비하게 된다. 따라서 circular 큐로 구현하는 경우도 있다.