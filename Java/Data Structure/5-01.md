# 01 여러 가지 자료구조

## 1. 선형 자료구조

* 앞의 요소와 뒤의 요소가 일대일의 관계이다.

### 1.1. 배열

![image](https://user-images.githubusercontent.com/27791880/152710673-d4b8fab9-d9ae-48b4-9d40-607620c358c7.png)

* 배열의 가장 큰 특징은 중간이 비어 있으면 안된다.

* 배열은 물리적 순서와 논리적 순서가 동일하다. 즉, 1번의 요소와 2번의 요소가 연달아 있다고 설명하면 그것이 실제로 메모리 상에도 해당 순서대로 배치되어 있어야 한다.

* 중간에 요소가 삭제되면 뒤의 요소를 당겨서 채워주어야 한다. 마찬가지로 중간에 요소를 삽입하려면 기존 요소들을 뒤로 밀어 공간을 만들어야 한다.

* 논리적 위치와 물리적 위치가 동일하기 때문에 특정 위치의 값을 가져오는 작업을 빠르게 수행할 수 있다.

* 자료를 넣고 뺄 때 소요되는 **computation time**은 배열의 개수에 의존적이기 때문에 배열의 개수가 n개라면 **O(n)** 이라고 표현한다.

### 1.2. 연결리스트 (LinkedList)

* 배열은 물리적으로 몇 개의 메모리를 사용할지 정한 뒤에 해당 사이즈만큼 할당을 받아서 사용한다. 

* 링크드리스트는 노드가 필요할 때 메모리를 할당받아서 사용한다.

* A, B, D 순서로 기존 노드들이 배치되어 있는데 여기서 B 뒤에 C를 추가하려면 C 뒤에 오는 노드는 D라고 알려준다.

* 링크드리스트는 다음 element를 가리키는 링크를 함께 가지고 있다. 이것이 C에서는 포인터로 작동한다. 자바에서는 객체의 참조변수를 가리키도록 구현하면 된다.

* 링크드리스트에서는 물리적 위치와 논리적 위치가 다를 수도 있다.

👉 LinkedList에 자료 추가하기

![image](https://user-images.githubusercontent.com/27791880/152711422-c85db79b-b9ed-48b4-8aaf-cdcd7e39afa2.png)

👉 LinkedList에서 자료 삭제하기

![image](https://user-images.githubusercontent.com/27791880/152711465-ed6f399f-0c9a-4287-afea-5613a1435e2b.png)

* 데이터를 추가하고 삭제하는 속도가 배열보다 linkedlist가 더 빠르다.

* 자료를 넣고 뺄 때 소요되는 **computation time**은 넣고 빼는 요소 한 가지에 대해서만 연산하면 되기 때문에 **O(1)** 이 된다.

* 한편, linkedlist는 배열처럼 index를 사용해서 특정 값을 찾아가는 것이 불가능하다. 따라서 논리적으로 연결된 순서에 따라서 원하는 값을 찾아가야 하는데, 이러한 문제 때문에 특정 값을 찾는데 소요되는 시간이 요소의 개수에 의존적이기 때문에 이 때는 **O(n)** 으로 표현할 수 있다.

### 배열과 링크드리스트의 차이점

* 배열은 자료의 추가삭제 비용이 크다. 그러나 원하는 자료의 위치를 아는 경우  자료를 꺼내오거나 검색하는 비용은 적다.

* Linkedlist는 자료의 추가삭제 비용은 적지만 특정 위치의 element를 찾는데 소요되는 시간은 배열보다 더 많이 걸린다.

### 1.3. 스택(stack)

* 가장 나중에 들어간 요소가 가장 먼저 나오게 된다. (LIFO, Last In First Out)

![image](https://user-images.githubusercontent.com/27791880/152714214-2e0ca0da-7460-4612-b83b-04b51f0c8155.png)

* DFS(깊이 우선 탐색)를 할 때도 스택을 활용한다.

### 1.4. 큐(Queue)

* 가장 먼저 입력된 자료가 가장 먼저 출력된다. (FIFO, First In First Out)

![image](https://user-images.githubusercontent.com/27791880/152714462-fba7b302-1d31-4459-bf1c-2a68b1acc72c.png)

* 큐에서 dequeue를 계속하게 되면 front의 메모리가 빈 공간이 되고 메모리를 낭비하게 된다. 따라서 circular 큐로 구현하는 경우도 있다.

<br/>

## 2. 비선형 자료구조

### 2.1. 트리(Tree)

* 부모 노드와 자식 노드 간의 연결로 이루어진 자료 구조

* 자식 노드는 반드시 2개인 것은 아니다. 2개 이상의 자식 노드가 있을 수 있고 완전히 없을 수도 있다.

* 자식 노드가 몇 개인지는 degree로 표현을 한다.

### 2.1.1. 이진트리 (binary tree)

* 부모노드에 자식노드가 두 개 이하인 트리

    ![image](https://user-images.githubusercontent.com/27791880/152735949-91974cda-ec31-4451-b848-24e568fdf155.png)

### 2.1.2. 이진 검색 트리 (binary search tree)

* 검색을 위해서 만들어진 트리

* 따라서 각 노드에 담기는 key는 중복되면 안된다. 유일한 element만 들어갈 수 있다.

    ![image](https://user-images.githubusercontent.com/27791880/152751497-4c611cfb-fddb-4861-af07-2e365b7dfdc4.png)

* 왼쪽 자식 노드는 부모 노드보다 작은 값을, 오른쪽 자식 노드는 부모 노드보다 큰 값을 가진다.

![image](https://user-images.githubusercontent.com/27791880/152752772-3a906994-3158-4067-b07c-cd15b92ca817.png)

* **Full binary tree(포화 이진트리)** 가 있다고 했을 때 이진 검색 트리가 빠른 이유는 다음과 같다.

    * 현재 위의 Full binary tree에는 15개의 노드가 있다.

    * 총 4단계의 레벨로 이루어져 있다.

    * 바이너리 트리가 꽉 차게 되면 depth가 n이라고 했을 때 전체 노드의 개수는 2<sup>n</sup> -1 개가 된다.

    * 따라서 검색 속도는 평균 log<sub>2</sub>n 이 된다.

* 이진 검색 트리에서 inorder traversal을 하게 되면 자료가 정렬되어 출력될 수 있다.

### 2.1.3. 힙(heap)

* 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리를 기본으로 한 자료구조이다.

* A가 B의 부모 노드라면, A의 키값과 B의 키값 사이에는 대소관계가 성립한다. 이 대소관계에 따라서 2가지 종류로 구분할 수 있다.

**Max heap** : 부모노드의 키값이 자식노드의 키값보다 항상 큰 힙.

**Min heap** : 부모노드의 키값이 자식노드의 키값보다 항상 작은 힙.

* Max heap에서 어떤 한 노드가 나오게 되면 나머지 전체 힙트리 중에서 가장 큰 노드가 루트로 올라간다. 이것을 알고리즘의 형태로 보면 **heap sort**라고 한다.

* 각 노드의 자식노드의 최대개수는 힙의 종류에 따라 다르지만, 대부분의 경우는 자식노드의 개수가 최대 2개인 이진 힙(binary heap)을 사용한다.

* 힙에서는 가장 높은(혹은 가장 낮은) 우선순위를 가지는 노드가 항상 뿌리노드에 오게 되는 특징이 있으며, 이를 응용하면 **우선순위 큐**와 같은 추상적 자료형을 구현할 수 있다.

* 우선순위 큐
    * 가장 우선순위가 높은 것부터 꺼내는 큐.

![400px-Max-Heap svg](https://user-images.githubusercontent.com/27791880/152749476-d50f3912-4993-48f0-b0c0-fac6119ddad9.png)

<br>

### Reference

* [위키백과: 힙(자료 구조)](https://ko.wikipedia.org/wiki/%ED%9E%99_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0))